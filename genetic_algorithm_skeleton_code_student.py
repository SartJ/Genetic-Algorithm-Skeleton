# -*- coding: utf-8 -*-
"""Genetic_Algorithm_Skeleton_Code_Student.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-l_qM-o8AoRoP8mfqg-IR67kB1Is2hAP

## CSE422 lab: Genetic Algorithm

#### Genetic Algorithm Pseudo code:

**function** GENETIC-ALGORITHM( population, FITNESS-FN) **returns** an individual 
 
> **inputs:** population- a set of individuals/chromosomes; FITNESS-FN- a function that measures the fitness of an individual

>**repeat** 
new_population $\leftarrow$ empty set 
>>**for** $i=1$ **to** size ($ population$) **do**
$$
\begin{array}{l}
x \leftarrow \text { RANDOM-SELECTION }(\text { population, FITNESS-FN }) \\
y \leftarrow \text { RANDOM-SELECTION }(\text { population, FITNESS-FN }) \\
child  \leftarrow \operatorname{CROSSOVER}(x, y)
\end{array}
$$
>>>**if** (some_random_number < mutation_threshold) **then** child$\leftarrow$ MUTATE ( child ) 

>>>add child to new_population 

>>population $\leftarrow$ new_population 

>**until** some individual is fit enough, or enough time has elapsed

>**return** the best individual in population, according to FITNESS-FN

### Skeleton Code:

### Importing libraries
"""

import numpy as np
import math

"""### Fitness function"""

def fitness(population, n):

  '''calculates the fitness score of each
     of the individuals in the population'''
     
  fit_score = [] # list to contain fitness score of each individuals
  j = 0
  while j < len(population):  # repeating for each individual
    attacking_pairs = 0     #total number of attacking queen pairs
    diagonal_pairs = 0  #no. of diagonal pairs
    for i,val in enumerate(population[j]):    # i = index of individual list , val = individual position
      attacking_pairs += math.comb(population[j].count(val),2) #finding no. of horizontal attacking pairs, using nC2 combination formula
      
      if i!=j:
        if abs(i-j) == abs(population[i]-population[j]):  #finding no. of diagonal attacking pairs
          diagonal_pairs += 1
    if diagonal_pairs!=0:     #dealing with duplicate values
      diagonal_pairs = diagonal_pairs/2
    fit_score.append(attacking_pairs+diagonal_pairs) 
    j += 1
    

  '''returns a 1D numpy array: index referring to 
     ith individual in population, and value referring 
     to the fitness score.'''


  return fit_score

"""### Random Selection function

This built-in function might help to create the weighted random selection:

`numpy.random.choice(a, size, replace, p)` 

`p` are the weights of the individuals- value between 0 and 1; refers to the probability of each individual being selected.

`a` is the array

`size` how many samples to return

`replace = True`
"""

def select(population, fit):
  ''' take input:  population and fit
      fit contains fitness values of each of the individuals 
      in the population  '''
  fit_pop_dict = dict(zip(fit, population)).items() #creates a dictionary with fitness as keys and populations as values
  sorted_fpd = sorted(fit_pop_dict, reverse=True)   #sorts the dictionary from highest fitness to lowest
  ''' return:  one individual randomly giving
      more weight to ones which have high fitness score'''
  a = [0,1,2,3,4]
  size = 1
  p = []

  f2, p2 = zip(*sorted_fpd)   #unzips the dictionary
  for i in f2[:5]:      #for the best 5 individuals appends the probability to be chosen to the list called p[]
    p.append(i/np.sum(f2))

  rando = numpy.random.choice(a, size, True, p)   #chooses a random number within 0-4

  

  
  return p2[rando]    #returns a random individual from the fittest 5

"""### Crossover function


**function** CROSSOVER $(x, y)$ **returns** an individual 

>**inputs**: $x, y$  which are the parent individuals

>$n \leftarrow \mathrm{LENGTH}(x) ; c \leftarrow$ random number from 1 to $n$ 

>**return** APPEND(SUBSTRING $(x, 1, c),$ SUBSTRING $(y, c+1, n))$
"""

def crossover(x, y):
  '''take input: 2 parents - x, y. 
     Generate a random crossover point. 
     Append first half of x with second 
     half of y to create the child'''
     
  '''returns: a child chromosome'''

     
  return

"""###Mutation function"""

def mutate(child):
  '''take input: a child
     mutates a random 
     gene into another random gene
     
     returns: mutated child'''
  

  return

"""### Genetic Algorithm Function"""

def GA(population, n, mutation_threshold = 0.3):
  '''implement the pseudocode here by
     calling the necessary functions- Fitness, 
     Selection, Crossover and Mutation'''
     fn = fitness(population, n)
     nmax = 10000
     nm = nmax
     while nm < 0 :
       new_pop = []
       j=0
       for i in population[j]:
         x = select(population, fn)
         y = select(population, fn)

         child =  crossover(x,y)
         rando = random.uniform(0, 1)
         if(rando < mutation_threshold):
           mutant = mutate(child)
           new_pop.append(mutant)
       population = new_pop
       j += 1
     nm -= 1
     fn2 = fitness(population, n)
     if 28 in fn2: break  


  '''print: the max fitness value and the 
     chromosome that generated it which is ultimately 
     the solution board'''
     for i in fn2:
       if i==28
        print(population[fn2.index(28)])
        break



  return

"""Running the Genetic Algorithm function"""

'''for 8 queen problem, n = 8'''
n = 8

'''start_population denotes how many individuals/chromosomes are there
  in the initial population n = 8'''
start_population = 10 

'''if you want you can set mutation_threshold to a higher value,
   to increase the chances of mutation'''
mutation_threshold = 0.3

'''creating the population with random integers between 0 to 7 inclusive
   for n = 8 queen problem'''
population = np.random.randint(0, n, (start_population, n))

'''calling the GA function'''
GA(population, n, mutation_threshold)